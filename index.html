<!DOCTYPE html>

<html>

<head>

    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
    <script src = "Crystal.js"></script>
    <script src = "Player.js"></script>
    <script src = "Enemy.js"></script>
    <script src = "Sword.js"></script>
    <script src = "EnemySpawner.js"></script>
    <script src = "Node.js"></script>
    <script src = "Path.js"></script>
    <script src = "Platform.js"></script>
 
</head>

<body>

    <script>
    let pgWidth = 1848;
    let pgHeight = 968;
    let swordDis = 65;
    let attackState = false;
    let faceLeft = false;
    let gameState = false;
    let playerState = 0;
    //let pointer = this.input.activePointer;    

    var config = {
        type: Phaser.AUTO,
        width: pgWidth,
        height: pgHeight,
        pixelArt: true,
        physics: {
            default: 'arcade',
        },

        scene: {
            preload: preload,
            create: create,
            update: update,
        }

    };
        
    var game = new Phaser.Game(config);
    var totalEnemies;
    var maxEnemies;

    //Game Objects
    var platforms;
    var player;
    var crystal;
    var enemies=[];
    var spawn1;
    var spawn2;
    var spawn3;
    var spawn4;

    var sword;
        
    var gui;
    var crystalHealth
    var gameOver;
    var instruction;
    var canAttack;
    var timedEvent;

    var Spawner;

    //Keyboard controls
    var cursors;
    var keys;
    var space;
        
    var path;
        
        
    let playerAnimations = {};   
    let enemyAnimations = {}
    let swordAnimations = {};
    
        
    function preload()
    {
        this.load.image('background', 'Assets/background1.png');
        this.load.image('platform', 'Assets/platform_1.png');
        this.load.atlas('player', 'Assets/knight_spritesheet.png','Assets/knight_spritesheet.json');
        this.load.image('crystal', 'Assets/crystal_final.png');    
        this.load.atlas('enemy', 'Assets/lavaMon.png', 'Assets/lavaMon.json');
        this.load.atlas('sword', 'Assets/sword_sw.png', 'Assets/sword_sw.json');

        this.load.audio('theme', 'Assets/crystal.wav');
}
        
    var totalEnemies;
    var numberEnemies;
    let spawners;
    let currentCrystal;
        
    function create()
    {

        spawners = [];
        totalEnemies = 20;
        maxEnemies = totalEnemies;
        numberEnemies = totalEnemies;

       path = new Path();


       let background = this.add.tileSprite(0, 0, pgWidth, pgHeight, 'background').setOrigin(0, 0);


       //Create the platforms and the player character set to collide with the platforms
       createPlatforms(this);
       

       currentCrystal = 1;
       crystal = new Crystal(this,plats[1].x,plats[1].y - 100,'crystal', 10);


       //enemies.push(new Enemy(this, 200, 533,'enemy'))
       //enemies[0].setPath(path, Array.from(path.map.keys()).find(val => val.x === crystal.x && val.y === crystal.y));
       
       player = new Player(this, 924, -65);
       
       counter = 0;   
       roundCount = 0;

        spawn1 = new EnemySpawner(5000,plats[2],enemies,this, totalEnemies, path, crystal);
        spawn2 = new EnemySpawner(5000,plats[0],enemies,this, totalEnemies, path, crystal);

        spawn3 = new EnemySpawner(4700, plats[3], enemies, this, totalEnemies, path, crystal);
        spawn4 = new EnemySpawner(5200, plats[4], enemies, this, totalEnemies, path, crystal);

       this.physics.add.collider(player, platforms);
       this.physics.add.collider(enemies, platforms);
       //Set up user input
       cursors = this.input.keyboard.createCursorKeys();
       keys = this.input.keyboard.addKeys('A, D, W, E');
       space = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
       space.on('down', player.jump); //calls jump function when space is pressed
        
       let music = this.sound.add('theme');
       music.loop = true;
       music.play();
        
       sword = new Sword(this, player.x+swordDis, 1500);
       sword.x = player.x + swordDis;

        
    //    for(var i=0; i<enemies.length; i++)
    //     {
    //         //enemies[i].enemyWalk();
    //         //enemies[i].play('walk')
    //     }
       
        //enemies.push(new Enemy(this, 1250, 0,'enemy'))
       this.physics.add.overlap(enemies, crystal, AttackCrystal, null, this); 
       this.physics.add.overlap(enemies,sword, EnemyKilled ,null,this); 
       
       gui = this.add.text(25, 20, '', {fontFamily: 'Bungee', fontSize: '32px', fill: '#f90000', fontStyle: 'bold', strokeThickness: '3', stroke: '#000000'});
       crystalHealth = this.add.text(25, 75, '', {fontFamily: 'Bungee', fontSize: '32px', fill: '#9f25c3', fontStyle: 'bold', strokeThickness: '3', stroke: '#000000'});
       gameOver = this.add.text((pgWidth/2)-210, (pgHeight/2)-250, '', {fontFamily: 'Bungee', fontSize: '70px', fill: '#da2828', fontStyle: 'bold', strokeThickness: '3', stroke: '#000000'});

       instruction = this.add.text((pgWidth/2)-365, (pgHeight/2)+150, '', {fontFamily: 'Bungee', fontSize: '50px', fill: '#ffffff', fontStyle: 'bold', strokeThickness: '3', stroke: '#000000'});

       gui.setText('Enemies left: '+ totalEnemies);

       crystalHealth.setText('Crystal Health: 10');
        
       var idle = this.anims.create({key: 'knight_idle', frames: this.anims.generateFrameNames('player', {prefix: 'knight_idle', end: 5, zeroPad: 2}), repeat: -1, frameRate: 5 });
       playerAnimations['idle'] = idle;
       var walk = this.anims.create({key: 'knight_walking', frames: this.anims.generateFrameNames('player', {prefix: 'knight_walking', end: 5, zeroPad: 2}), repeat: -1, frameRate: 8 });
       playerAnimations['walking'] = walk;
       var jumps = this.anims.create({key: 'knight_jumping', frames: this.anims.generateFrameNames('player', {prefix: 'knight_jumping', end: 7, zeroPad: 2}), repeat: -1, frameRate: 10 });
       playerAnimations['jumping'] = jumps;
        
       var swing = this.anims.create({key: 'sword_swing', frames: this.anims.generateFrameNames('sword', {prefix: 'sword_swing', start: 0, end: 3, zeroPad: 2}), repeat: 0, frameRate: 28 });
       swordAnimations['swing'] = swing;
       var swing_complete = this.anims.create({key: 'sword_sw', frames: this.anims.generateFrameNames('sword', {prefix: 'sword_swing', start: 4, end: 5, zeroPad: 2}), repeat: 0, frameRate: 28 });
       swordAnimations['swing_complete'] = swing_complete; 
            
       player.play(playerAnimations['idle']);    
       
    }

    let plats;    
        
    function createPlatforms(scene)
    {
        plats = [];
        
        platforms = scene.physics.add.staticGroup();

        platforms.create(250, 300, 'platform').setDisplaySize(500, 50).refreshBody();
        
        platforms.create(924, 500, 'platform').setDisplaySize(500, 50).refreshBody(); 
        
        platforms.create(1598, 300, 'platform').setDisplaySize(500, 50).refreshBody();
        
        platforms.create(250, 700, 'platform').setDisplaySize(500, 50).refreshBody();
        
        platforms.create(1598, 700, 'platform').setDisplaySize(500, 50).refreshBody();
        
        
        
        platforms.getChildren().forEach(val => {
            plats.push(new Platform(val.x, val.y, 500, path));
        });
        plats[0].connectRight(plats[1].leftSide, path);
        plats[1].connectLeft(plats[3].rightSide, path);
        plats[2].connectLeft(plats[1].rightSide, path);
        plats[4].connectLeft(plats[1].rightSide, path);
        
    }
        
    function update()
        {   
            //console.log(this.timedEvent.getProgress());
            
            if (keys.E.isDown && gameState === false){
                gameState = true;
                instruction.setText('');
                player.setGravityY(3000);
            }
            if (gameState){
                if (player.y > 1200) 
            {
            gameOver.setText('Game Over');
            //console.log("GAME OVER");
            game.destroy();
            //this.gameOver();
        }
                      
        
        sword.y = player.y;
        
        if (faceLeft){
            sword.x = player.x + (swordDis * -1);
            player.flipX = true;
            sword.flipX = true;
        }
        else{
            sword.x = player.x + swordDis;
            player.flipX = false;
            sword.flipX = false;
        }
        
        //Player will not move in the x-axis unless a movement key is being pressed
        player.setVelocityX(0);

        //Player has "drag" on the x-axis meaning they slide a bit after an input
        player.setDragX(400);
        if (player.body.touching.down)
        {
            player.jumpCount=0;
        }
        //Handle player movements
        if (cursors.left.isDown || keys .A.isDown)
        {
            player.setVelocityX(-450);
            faceLeft = true;
            player.play(playerAnimations['walking'],true);
        }
        if (cursors.right.isDown || keys.D.isDown)
        {
            player.setVelocityX(450);
            faceLeft = false;
            player.play(playerAnimations['walking'],true);
        }
        if (cursors.up.isDown || keys.W.isDown)
        {
            player.jump();
        }
                
        if (!(cursors.left.isDown || keys .A.isDown || cursors.right.isDown || keys.D.isDown || cursors.up.isDown || keys.W.isDown))  {
            player.play(playerAnimations['idle'],true);

        }      
        
        this.input.on('pointerdown', function (pointer)
        {

            
                swordDis = 65;
                canAttack = false;
                attackState = true;
                sword.play(swordAnimations['swing'],true);
                

        }, this)
        
        this.input.on('pointerup', function (pointer)
        {
            canAttack = true;
            attackState = false;
            sword.play(swordAnimations['swing_complete'],true);
            
        }, this)
        
        for(let i=0; i<enemies.length; i++)
        {

            enemies[i].moveEnemy();

        }
        for(let i=0; i<enemies.length; i++)
        {
                if( enemies[i].y>1100)
            {
                EnemyDeath(enemies[i]);
                enemies[i].setY(400)
            }
        }
            }
        else{
            instruction.setText('Press E to Start the Game');
        }
        
            
        if (maxEnemies <= 0) {
            let newLocation = Phaser.Math.Between(0, 2);
            while (newLocation === currentCrystal) {
                newLocation = Phaser.Math.Between(0, 2);
            }
            currentCrystal = newLocation;
            crystal.disableBody(true, true);          
            crystal = new Crystal(this, plats[newLocation].x, plats[newLocation].y - 100, 'crystal', crystal.crystalHP);
            this.physics.add.overlap(enemies, crystal, AttackCrystal, null, this); 

            if (newLocation === 0) {
                spawn1.destroy();
                spawn2.destroy();
                spawn3.destroy();
                spawn4.destroy();
                spawn1 = new EnemySpawner(spawn1.delay * 0.9,plats[2],enemies,this, Math.round(numberEnemies), path, crystal);
                spawn3 = new EnemySpawner(spawn3.delay * 0.9, plats[3], enemies, this, Math.round(numberEnemies), path, crystal);
                spawn4 = new EnemySpawner(spawn4.delay * 0.9, plats[4], enemies, this, Math.round(numberEnemies), path, crystal);
            } else if (newLocation === 1) {
                spawn1.destroy();
                spawn2.destroy();
                spawn3.destroy();
                spawn4.destroy();
                spawn1 = new EnemySpawner(spawn1.delay * 0.9,plats[2],enemies,this, Math.round(numberEnemies), path, crystal);
                spawn2 = new EnemySpawner(spawn2.delay * 0.9, plats[0], enemies, this, Math.round(numberEnemies), path, crystal);
                spawn3 = new EnemySpawner(spawn3.delay * 0.9, plats[3], enemies, this, Math.round(numberEnemies), path, crystal);
                spawn4 = new EnemySpawner(spawn4.delay * 0.9, plats[4], enemies, this, Math.round(numberEnemies), path, crystal);
            } else if (newLocation === 2) {
                spawn1.destroy();
                spawn2.destroy();
                spawn3.destroy();
                spawn4.destroy();
                spawn1 = new EnemySpawner(spawn1.delay * 0.9,plats[0],enemies,this, Math.round(numberEnemies), path, crystal);
                spawn3 = new EnemySpawner(spawn3.delay * 0.9, plats[3], enemies, this, Math.round(numberEnemies), path, crystal);
                spawn4 = new EnemySpawner(spawn4.delay * 0.9, plats[4], enemies, this, Math.round(numberEnemies), path, crystal);
            }
            numberEnemies = Math.round(numberEnemies * 1.2);
            maxEnemies = numberEnemies;
            gui.setText("Enemies left: " + numberEnemies);
            roundCount = 0;
            totalEnemies = numberEnemies;
        } 
        
    }
    
        
    
    function AttackCrystal(enemy)
    {
        EnemyDeath(enemy);
        crystal.loseHP();
        crystalHealth.setText('Crystal Health: ' + crystal.crystalHP);
        
    }

    roundCount;


    function EnemyKilled(enemy)
    {
        
        if (attackState){
            //enemy.setVelocityY(-500);
            EnemyDeath(enemy);
            //console.log("gone")
        }
    }
    function EnemyDeath(enemy)
    {
        enemy.disableBody(true,true)
        maxEnemies--;
        gui.setText('Enemies left: ' + maxEnemies);
        
    }
        
    </script>

</body>

</html>
    